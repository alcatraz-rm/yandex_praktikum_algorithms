"""
https://contest.yandex.ru/contest/23815/run-report/106521386/

-- ПРИНЦИП РАБОТЫ --
Для поиска элемента используем бинарный поиск. Каждый раз вычисляем средний элемент массива и проверяем, не совпадает
ли он с target. Если совпал, то мы нашли искомый элемент. Если нет, то проверяем, если левая половина отсортирована
(условие nums[left] <= nums[mid]) и наш элемент лежит в этом диапазоне, то переходим в левую половину, если же не лежит,
то переходим в правую. Если же левая половина не отсортирована, то отсортирована правая. Проверяем, лежит ли target в
правой половине (смотрим диапазон), если да, то переходим в нее. Если нет, то переходим в левую. Таким образом, мы найдем
target, если он есть в массиве.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Заметим, что если мы разделим массив на две половины, то одна всегда будет отсортирована. Мы можем вычислить, какая из
половин имеет такое свойство. Далее мы можем точно сказать, лежит ли target в этой половине, достаточно просто проверить,
попадает ли он в диапазон между крайними элементами заданной половины. Если да, то продолжаем поиск в данной половине.
Если нет, то ищем в другой половине.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Данный алгоритм представляет собой модифицированный бинарный поиск, который на каждом шаге делает больше сравнений, чем
обычный бинарный поиск, в силу специфики входных данных. Однако сложность от этого асимптотически не меняется, мы по-прежнему
делаем O(log N) итераций.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Используется константное количество дополнительной памяти: длина массива, указатели left и right.

Поэтому пространственная сложность составляет O(N).
"""


def broken_search(nums, target) -> int:
    n = len(nums)
    left = 0
    right = n - 1

    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid
        elif nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                right = mid - 1
            else:
                left = mid + 1
        else:
            if nums[mid] < target <= nums[right]:
                left = mid + 1
            else:
                right = mid - 1

    return -1


def test():
    arr = [19, 21, 100, 101, 1, 4, 5, 7, 12]
    assert broken_search(arr, 5) == 6


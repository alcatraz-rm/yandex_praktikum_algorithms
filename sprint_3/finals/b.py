"""
https://contest.yandex.ru/contest/23815/run-report/105815640/

-- ПРИНЦИП РАБОТЫ --
Реализована классическая быстрая сортировка с одним улучшением: разбиение происходит in place. На каждом шаге
случайным образом выбирается опорный элемент. Далее в функции partition он убирается на последнее место отрезка, чтобы
сам опорный не участвовал в процессе. Далее применятся описанная в условии задачи процедура: двигаем указатель left,
пока элемент не превосходит опорного. Затем двигаем right, пока элемент превосходит опорный (или равен ему). Затем,
когда не можем двигать ни один из указателей и left < right, меняем местами элементы по данным индексам
(если left все еще меньше right), так как они нарушают порядок и должны быть в других половинах массива.
Далее продолжаем процедуру, пока индексы не столкнуться или right не уйдет за left.
Затем опорный элемент ставим на свое место.

Для данной задачи реализовал компаратор, который будет корректно сравнивать элементы, в соответствии с условием задачи.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Корректность алгоритма обоснована в теоретической части. Корректность процедуры partition также очевидна, так как из
описания процедуры в условии задачи понятно, что с необходимостью левее указателя left окажутся все элементы, которые
меньше опорного, а справа от указателя right - все элементы, которые больше опорного.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Временная сложность равна сложности классической быстрой сортировки. В худшем случае она составляет O(N^2).
Сложность в среднем составляет O(N * log N).

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Пространственная сложность обычной быстрой сортировки складывается из памяти, которая используется рекурсией, и памяти,
которая используется алгоритмом. Количество рекурсивных вызовов составляет O(N), память, которую расходует алгоритм,
составляет 2 * O(N), поэтому получаем 2 * O(N) + O(N) = O(3 * N) = O(N) (в худшем и в среднем).

Если же рассмотреть улучшенный вариант, то получается, что сам алгоритм больше не расходует дополнительной памяти,
только на хранение массива. Поэтому в худшем случае получаем O(N) + O(N) = O(2 * N) = O(N). Улучшили константу.
Если рассмотреть сложность в среднем, то получаем, что глубина рекурсии при удачном выборе опорного элемента каждый раз
будет O(N) + O(log N) = O(N).
Но условие задачи выполнено - алгоритм не использует O(N) дополнительной памяти.
"""


import random


def compare(x, y):
    if x[1] != y[1]:
        return x[1] - y[1]
    else:
        if x[2] != y[2]:
            return y[2] - x[2]
        else:
            if x[0] < y[0]:
                return 1
            elif x[0] == y[0]:
                return 0
            else:
                return -1


def partition(arr, left_initial, right_initial, pivot_index, comp):
    p = arr[pivot_index]
    arr[pivot_index], arr[right_initial] = arr[right_initial], arr[pivot_index]

    left = left_initial
    right = right_initial - 1

    while left <= right:
        while left <= right and comp(arr[left], p) >= 0:
            left += 1
        while left <= right and comp(p, arr[right]) >= 0:
            right -= 1

        if left < right:
            arr[left], arr[right] = arr[right], arr[left]

    arr[right_initial], arr[left] = arr[left], arr[right_initial]
    return left


def qsort(arr, left_initial, right_initial, comp=lambda x, y: y - x):
    if right_initial - left_initial < 2:
        return
    pivot_index = random.randint(left_initial, right_initial - 1)
    mid = partition(arr, left_initial, right_initial - 1, pivot_index, comp)

    qsort(arr, left_initial, mid, comp)
    qsort(arr, mid + 1, right_initial, comp)


n = int(input())
arr = []
for _ in range(n):
    row = input().split()
    arr.append((row[0], int(row[1]), int(row[2])))

qsort(arr, 0, n, comp=compare)
for x in arr:
    print(x[0])
